# 1.1 실행시간
**알고리즘** 은 주어진 문제를 유한한 시간 내에 해결하는 단계적 절차를 말한다. **데이터구조** 는 데이터를 조직하고 접근하는 체계적 방식을 말한다.            
우리의 최대 관심사는 **좋은** 알고리즘과 데이터구조를 설계하는 것이다. 

## "좋은" 의 척도
첫째, 알고리즘과 데이터구조 작업에 소요되는 **실행시간**           
둘쨰, 기억장소 사용량             
***
_실행시간과 기억장소 사용량 둘 중에는 어느 것이 더 중요할까?_                 
실행시간이 빠르더라도 기억장소 요구량이 너무 크거나, 기억장소 요구량은 많지 않지만 실행시간이 너무 느리다면 좋은 프로그램이라고 할 수는 없다.             

## 1.1.1 평균실행시간과 최악실행시간 
대부분의 알고리즘은 입력을 출력으로 변환한다. 알고리즘의 **실행시간** 은 대체로 입력의 크기와 함께 증가한다.          
실행시간에는 _최선실행시간, 평균실행시간, 최악실행시간_ 의 세 가지가 있다.
***
최선실행시간 - 최선이란 제일 운 좋은 경우의 성능이므로 알고리즘의 전체적 성능을 대표한다고 볼 수 없기 때문이다.                   
평균실행시간 - 알고리즘을 평균적인 입력으로 실행한 결과를 말한다. 언뜻 그럴듯한 척도로 보이지만 현실적으로 평균적인 입력이 무엇인지 결정하기 어렵다.                 
최악실행시간 - 어떤 알고리즘이 입력에 대한 출력을 얻기 위해 가장 오랜 시간이 걸리는 경우를 기준으로 하여 그 알고리즘의 실행시간을 구한다는 말이다.            

## 1.1.2 실행시간 구하기           
### 실험적 방법
- 우선, 알고맂므을 구현하는 프로그램을 작성한다.
- 다음, 프로그램을 다양한 크기와 요소로 구성된 입력을 사용하여 실행한다. 이때 시스템 콜을 사용하여 실제 실행시간을 정확히 측정한다.
- 마지막으로, 결과를 도표로 작성한다. 그리고 나서 도표로부터 최악의 경우에 대한 데이터를 수집한다.
***
**<한계>**                
첫째, 실험 결과가 실험에 포함되지 않은 입력에 대한 실행시간을 제대로 반영하지 않을 수 있다.            
둘째, 만약 두 개의 알고리즘을 비교하고 싶다면 반드시 동일한 하드웨어와 소프트웨어 환경이 사용되어야 한다.         
셋째, 실행을 위해서는 알고리즘을 완전한 프로그램으로 구현해야 하는데 이 자체가 매우 어려울 수가 있다.        

### 이론적 방법
이론적 방법은 앞서 설명한 실험적 방법의 모든 단점들을 극복한다.         
첫째, 모든 입력 가능성을 고려한다.           
둘째, 하드웨어나 소프트웨어와 무관하게 알고리즘의 속도 평가가 가능하다. (실제로는 실행시간을 입력 크기 **n**의 함수로 규정한다.)   
셋째, 알고리즘을 구현한 프로그램 대신, 고급언어, 구체적으로는 의사코드로 표현된 알고리즘을 사용한다.          

